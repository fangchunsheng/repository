
今天是光棍节，心情莫名的压抑，可能和节日有关，也可能是因为其他，whatever,反正就是心情不好（貌似心情已经好久都没好过了）。 于是就想到说去学学人家大牛，跑到leetcode、lintcode上去刷题，心中居然有些小激动，仿佛自己已经找到了通往大神的路。遂跑去两个官网，以最快的速度进行了注册，毕竟马上就要跻身大牛的行列了。接着就准备开始大战了，leetcode是英文，lintcode是中文版的，那我显然是要选择leetcode呀，毕竟逼格一下子就起来了，在leetcode上面的第一题是the two,题目描述是：  
> Given an array of integers, return indices of the two numbers such that they add up to a specific target.  
You may assume that each input would have exactly one solution.  
>
EXAMPLE :  
Given nums = [2, 7, 11, 15], target = 9,  
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].

第一眼就懵逼了，当然我想到的第一个方法是暴力遍历尝试，这种方法肯定是可行的，但以往学习算法的经历告诉我，题目原意绝对不是希望用这种暴力方式解决的。思考两分钟后无果（果然不是大牛的料）,跑去百度上面搜索了一下，大概看到了两种方法。  

* 方法一
 使用hashmap，将数组中的每个值作为key,然后将索引做为value建立一个map。接着遍历数组，每遍历一个元素item,就用 sum-item,然后得出另一个值，然后去map里面查这个索引是否存在。这个方法主要就是用空间换取时间，时间复杂度O(n)。
* 方法二  
先对整个数组进行排序。  
然后将第一数值和最后一个数值相加，如果和大于给定的值，那么尾巴上的指针就向前移动，如果和小于给定的值，那么头上的指针就想后移动，这样一直遍历，直到找到和等于给定的值（题目说了，一个是存在这样的以对索引的，不怕找不到）

瞬间被打击，心情不好。
问题的关键是，看到方法二中的排序，头脑中立马想到快速排序，进而想到快速排序是怎么实现的呢。喔噢，全tm忘了，还依稀记得以前推导过这个算法好多次了，然而还是忘了，心情已到谷底。  

倔强如我，我一定要回忆起来当时是怎么实现的，对，就是回忆，不是思考。遂找来了笔和本(麻蛋发现笔只有笔芯，连个壳儿都没有，本儿更是空隙的地方都没有了，说的好想之前很用功一样)。回忆呀回忆，回忆呀回忆...  但我坚决不去网上看。   

对，我好想想起来了一点，快速排序主要的思想是divide and conqure，将一个数组分成为两半截，前面一截的所有元素小于某个*基准值*，后面一截的所有元素大于这个*基准值*，然后对前半截和后半截的两个数组进行同样的划分，这样分出来的数组继续这样分下去，最终整个数组肯定就是有序的了。  

其实上面这个divide and conqure的整体思想我一直都能理解，重点在于如何将这个数组划分成为两半截，使得左边的全部小于基准值，右边的全部大于基准值。不得不说回忆确实起作用了，我居然能想起来这个划分过程的大概步骤来。
可能是我之前在这个步骤上困了太久了。  

假如以数组中的第一个元素为基准值（基准值实际上可以是素组中的随意值）  
用一个临时变量存储这个基准值  int base = items[0]  
指针i,j分别指向数组的头和尾巴，从尾巴向前面看，只要尾巴上的大于基准值，j指针就往前面移，一直到遇到一个小于基准值的值，这个时候讲j指向的元素移动到i指向的位置，并且i指针向后移动。从现在起，从i指针位置想后看，凡是i指针所指元素大于基准值，那么i就向后移动，直到遇到一个大于基准值的元素，这个时候，将这个元素移动j指针指向的位置，同时j向前面移动。然后循环前面的操作，直到i遇到了j,说明基准值已经找到他本应在的地方。

```
public static void partition(int[] items,int i,int j){
      int base = items[i];
      while(i<j){
          while(i<j && base < items[j]){
              j--;
          }
          if(i<j){
              items[i] = items[j];
              i++;
          }
          while(i<j && base > items[i]){
              i++;
          }
          if(i<j){
              items[j] = items[i];
              j--;
          }
      }
      items[j] = base;
  }
```

这个代码写出来后，大概测试了一下，应该是没有什么大问题，除非一些极端情况没有考虑到。。

其实就这个划分过程，我一直都有一种恍惚感觉，就是感觉到他确实是对的，但又不知道为什么他对，或者说不知道怎么解释这个过程是对的。所以我一直想找一个我自己能很容易理解的对上面划分过程的解释。    

就在刚刚在回忆的过程，就在刚刚在纸上胡乱划的过程，我突然联想到最近项目中遇到的一个问题和这个有些相似。   
项目中的问题是，一个影院在一个月的结算算过程中，可能有好几个结算对象，可能一段时间和院线1结算，一段时间和院线2结算，还有一段时间和院线3结算，那么中间有可能有空隙时间段，没有设置任何计算对象，这样的话，他的结算对象就是自己。举一个列子我要获取10.1~10.31所有结算对象，一个每个对象对应的时间段，可能9.1~10.3和院线1 10.10~10.20和院线2  10.28~11.5和院线3，我最终要获取的是：  

|时间段|结算对象|
|:-:|:-:|
|10.1~10.3|院线1|
|10.4~10.9|影院自己|
|10.10~10.20|院线2|
|10.21~10.27|影院自己|
|10.29~10.31|院线3|

这个估计对于某些大牛来说是分分钟的事情，但我这种接近渣渣的还是想了好一阵子才想出了具体的实现。  
**我的大致想法是，树立一个基准线，在基准线之前时间的表示我已经处理过了，那这段时间我再也不管了，那我现在只需要处理后面的更小的一个时间段了，在处理后面时间段的过程中，基准线一直向后移动，需要处理的时间段也越来越小，直到后面的时间段都处理完，其实整个过程也是一个divide and conqure的过程，不断缩小问题规模，然后解决小规模的问题。**

项目中的经历突然启发了我，在上面数组划分的过程中，其实也可以用这种思想。  
* 我们的目的是将所有大于基准值的值扔到左边，所有小于基准值的值扔到右边。那么我将一个大于基准值值扔到数组的最左边，那么我的问题规模是不是又小了一点，如果原来我们需要处理的是索引从0~n-1的数组,那么我现在要处理的是只是索引0~n-2的问题了。同样，如果我们把一个小于基准值的值，扔到了最右边，那么我们处理问题的规模又变小了，变成了处理索引从1~n-2的数组的划分的问题了。这样不断处理下去，总有个时候，需要我们的处理的数组大小变成为1，
这个时候，也就意味着整个划分过程处理完毕。  

* 在每一个待出处理的数组中(小规模数组，已经处理过的我们就不管了)，都会有一个空白的位置，这个位置要么在最左边，要没在最右边。这个空白位置和这剩余的未处理值共同构成了这个小规模问题。我们可以理解为空白位置一直在等一个给他传一个小于（或大于）基准值的值，以减小问题规模，同时在等待的过程中，对应的另一端也在一直减小问题规模。  

算了还是吧完整的快速排序给写一遍吧：  
麻蛋 刚刚还调了老半天 搞得要要怀疑自己了
```
package com.maizuo.com;

import java.util.Arrays;

/**
 * Created by Lenovo on 2016/11/11.
 */
public class QuickSort {

    public static void main(String[] args) {
        int test[] = new int[]{2,1,4,2,16,2,7,9,2,34,6};
        quickSort(test,0,test.length-1);
        System.out.println(Arrays.toString(test));
    }

    public static void quickSort(int[] items,int i,int j){
        if(i<j) {
            int baseIndex = partition(items, i, j);
            quickSort(items, i, baseIndex - 1);
            quickSort(items, baseIndex + 1, j);
        }

    }

    static int  partition(int[] items, int i, int j){
        int base = items[i];
        while(i<j){
            while(i<j && base < items[j]){
                j--;
            }
            if(i<j){
                items[i] = items[j];
                i++;
            }
            while(i<j && base > items[i]){
                i++;
            }
            if(i<j){
                items[j] = items[i];
                j--;
            }
        }
        items[j] = base;
        return i;
    }
}

```

表示第一次写这么多^^
