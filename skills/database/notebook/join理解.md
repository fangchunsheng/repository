### 对数据库中join的理解

#### 数据库中的集中join操作：
* inner join,最强约束匹配，只有全部符合的数据才会留下
* left join,保留左表内的所有数据，右表无对应的用null代替
* right join,保留右表内的所有数据，左表无对应的用null代替
* full join,保留左右表内的所有数据，对应表内无对应数据用null代替
* cross join,将左表内的每一行数据与右表内的每一行数据进行相关关联后输出

#### join的三种算法如下：

* Nested loop join  
nested loop join是最容易想到的一种join算法，也是最笨的办法。如果表A和表B用nested loop join进行join,那么就是从A中去取出一条数据，然后在右表中等值查询的方式进行匹配，为了效率，一般情况下会自动选择B表中的索引进行这种匹配以加速查找。  
example:

|TableA(col1)|     
|:-:|
|0|
|1|
|2|
|3|

|TableB(col1)|     
|:-:|
|1|
|2|
|3|
|4|

假如TableA是驱动表，那么预算过程如下：  
从Table表中取出一行，我们认为是0这一行，去TableB中去查找是否有col1=0的记录？发现没有，于是进行下一行进行查找，也就是1这一行，去B中查找是否有col1=1的记录，发现确实有，于是就拼成一组记录返回。  
可以发现驱动表A表在nested loop join过程是是无法使用任何索引的。而目标表B表是可以使用二分查找来加速的，因此原则上驱动表必须是一个数据量较小的表，被驱动表则最好有针对匹配条件的索引。

* Hash join
Hash join的思路是使用hash映射表的方式进行匹配。  
他假定也是一个大表和小标进行join,如果小标能全部装入到内存，那么如果能将小表以匹配条件作为key,记录做为value,组成一个hashMap,我们就可以利用Map的contains方法来快速的查找到所有符合join要求的结果了。

* Sort merge join
若两张表能够按照匹配条件进行排序，那么sourt merge就能够用很低的内存消耗来完成join操作了。因为两张表都是有序的，所以只需要顺序的从左表和右表中取出数据，进行拼装即可。

##### 总结
Nested loop 和hash join ，都能够比较轻松的处理小表和大表的取交集场景，其中nested loop要求大表有索引，如果小表可以完全的被放到内存中，那么hash join是一个比较好的处理大小表join的方式。  
Sort merge join 则要求两张表都需要按照匹配条件排序，这个的构建成本略高，但它的优势是，排序过程对内存要求较低，并且可以充分的并行执行，因此可以发现，它经常出现在列存，倒排索引等各类条件变化频繁，数据量非常大的场景中。
